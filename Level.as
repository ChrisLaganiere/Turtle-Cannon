package{	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.ColorTransform;	import flash.geom.Point;		public class Level extends MovieClip	{		//Children with frame actions		public var frameChildren:Vector.<MovieClip> = new Vector.<MovieClip>();		public var myHeight:int; //tells Player when to bounce on floor				var player:Player;		var levelLength:int; //how long level is		var currentLength:int = 0; //how far you've gone so far		var cannonDistance:int; //distance since last cannon		var crowDistance:int;		var cannonConstant:int;		var cannonFlexibility:int;		var crowConstant:int;				var rNew:Number;		var gNew:Number;		var bNew:Number;		var rOld:Number;		var gOld:Number;		var bOld:Number;		var rChange:Number;		var gChange:Number;		var bChange:Number;		var rDiff:Number;		var gDiff:Number;		var bDiff:Number;		var newColorTransform:ColorTransform;				private var goalDeployed:Boolean = false;				public function Level()		{			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onAddedToStage(event:Event):void		{			player = new Player;			addChild(player);			player.x = Main.stageW/2;			player.y = this.height - Main.stageH/2;			myHeight = this.height;			cannonDistance = bgbox.height - Main.stageH;			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			levelLength = Math.ceil(2500 + 5000*Math.random());			varSet();			colorize(0);		}		private function onRemovedFromStage(event:Event):void		{			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);		}		private function varSet():void		{				crowDistance = 100;			cannonConstant = 200;			cannonFlexibility = 300;			crowConstant = 150;			//Colors			rOld = int(255*Math.random());			gOld = int(255*Math.random());			bOld = int(255*Math.random());			rNew = int(255*Math.random());			gNew = int(255*Math.random());			bNew = int(255*Math.random());			rDiff = (rNew - rOld);			gDiff = (gNew - gOld);			bDiff = (bNew - bOld);			newColorTransform = bgbox.transform.colorTransform;			newColorTransform.alphaOffset = 1;			newColorTransform.redMultiplier = 0;			newColorTransform.greenMultiplier = 0;			newColorTransform.blueMultiplier = 0;		}		public function frameActions():void		{			player.frameActions();			for (var i:int = 0; i < frameChildren.length; i++)			{				frameChildren[i].frameActions();			}			frameChildren = new Vector.<MovieClip>();			boundaries();		}		private function boundaries():void		{			if (player.canWin && player.y + this.y < 0)			{					//player at top of level				Main.nextLevel = -2;				Main.endLevel = true;				Main.startLevel = true;			}			else if (this.localToGlobal(new Point(player.x, player.y)).y < (1/4)*Main.stageH)			{	//player above -> Screen Scrolling				var scrollAmount:Number = .5*((1/4)*Main.stageH - this.localToGlobal(new Point(player.x, player.y)).y);				if (currentLength + scrollAmount > levelLength)				{					//shouldn't scroll any more					scrollAmount = (levelLength-currentLength);				}				this.y += scrollAmount;				currentLength += scrollAmount;				bgbox.y = -this.y - 100; //colored background rectangle				colorize(currentLength/levelLength);				//place cannons				cannonDistance -= scrollAmount;				if (levelLength - currentLength <= 300)				{					addGoalCannon();				}				else if (cannonDistance < 1)				{					addCannon();				}			}			else if (this.localToGlobal(new Point(player.x, player.y)).y > Main.stageH)			{				if (currentLength > 10)				{					Main.nextLevel = -1;					Main.endLevel = true;					Main.startLevel = true;				}			}		}		private function colorize(amount:Number):void		{	//amount should be current height (percent)			rChange = Math.floor(rOld + amount*rDiff);			gChange = Math.floor(gOld + amount*gDiff);			bChange = Math.floor(bOld + amount*bDiff);			//not accurate (conversion error) --- newColorTransform.color = Number("0x" + rChange.toString(16) + gChange.toString(16) + bChange.toString(16));			newColorTransform.redOffset = rChange;			newColorTransform.greenOffset = gChange;			newColorTransform.blueOffset = bChange;			bgbox.transform.colorTransform = newColorTransform;		}		private function addCannon():void		{			var newCannon:Cannon;			if (Math.random() + (currentLength/levelLength) > 1)			{				newCannon = new MovingCannon;			}			else			{				newCannon = new StationaryCannon;			}			addChild(newCannon);			newCannon.y = -this.y - 100 - cannonDistance;			cannonDistance += cannonConstant + cannonFlexibility*Math.random();			newCannon.x = Math.round(40 + (Main.stageW-80)*Math.random());		}		private function addGoalCannon():void		{			if (!goalDeployed)			{				var newCannon:Cannon;				newCannon = new GoalCannon;				addChild(newCannon);				newCannon.y = -this.y;				newCannon.x = Main.stageW/2;				goalDeployed = true;			}		}	}}